import React from 'react';
import { TFlowActionOptions, TFlowBackMethodOutput, TFlowDispatchMethodOutput, TFlowLastAction, TFlowListen, TFlowListenCallback, TFlowManagerOptions, TFlowStartMethodOutput, TScreen, TScreens, TStepOptions } from '../../types';
import { Step } from '../step';
export declare class Flow {
    name: string;
    baseUrl: string;
    steps: Record<string, Step>;
    anotherObjects: Record<string, Step>;
    last2Steps: Record<number, string>;
    history: Array<string>;
    listeners: Record<TFlowListen, TFlowListenCallback[]>;
    fromFlowName?: string;
    initialStepName?: string;
    lastRenderStepName?: string;
    lastAction?: TFlowLastAction;
    constructor(name: string, baseUrl: string);
    private get stepsArray();
    private get firstStepName();
    private get lastStepName();
    private get currentStepName();
    private set currentStepName(value);
    private logger;
    private callListeners;
    hasPreviousStep: () => boolean;
    getPreviousStep: () => Step | undefined;
    getCurrentStep: () => Step | undefined;
    getHistory: () => string[];
    getLastAction: () => TFlowLastAction | undefined;
    addStep: <TScreensInner extends TScreens, TScreen extends TScreen>(screen: TScreen, name: string, options?: TStepOptions) => void;
    addAction: (screenName: string, actionName: string, gotoScreenName: string, isAnotherObject?: boolean) => void;
    addListener: (callback: TFlowListenCallback, type?: TFlowListen) => void;
    private stepUrl;
    private buildUrl;
    render: (options: TFlowManagerOptions) => React.ReactNode;
    start: (stepName?: string, fromFlowName?: string, options?: TFlowActionOptions, isFromBack?: boolean) => TFlowStartMethodOutput;
    mount: () => void;
    back: () => TFlowBackMethodOutput;
    private removeLastStepHistory;
    clearHistory: () => void;
    private treatHistory;
    dispatch: (screen: TScreen, actionName: string, payload?: Record<string, any>) => TFlowDispatchMethodOutput;
}
